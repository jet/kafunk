namespace Kafunk

open System
open System.Threading
open System.Threading.Tasks

// TODO: https://github.com/fsprojects/FSharp.Control.AsyncSeq

/// An asynchronous sequence represents a delayed computation that can be
/// started to produce either Cons value consisting of the next element of the
/// sequence (head) together with the next asynchronous sequence (tail) or a
/// special value representing the end of the sequence (Nil)
type AsyncSeq<'T> = Async<AsyncSeqInner<'T>>

/// The interanl type that represents a value returned as a result of
/// evaluating a step of an asynchronous sequence
and AsyncSeqInner<'T> =
  | Nil
  | Cons of 'T * AsyncSeq<'T>


/// Module with helper functions for working with asynchronous sequences
module AsyncSeq =

  /// Creates an empty asynchronou sequence that immediately ends
  [<GeneralizableValue>]
  let empty<'T> : AsyncSeq<'T> = async { return Nil }

  /// Creates an asynchronous sequence that generates a single element and then ends
  let singleton (v:'T) : AsyncSeq<'T> = async { return Cons(v, empty) }

  /// Yields all elements of the first asynchronous sequence and then
  /// all elements of the second asynchronous sequence.
  let rec append (seq1:AsyncSeq<'T>) (seq2:AsyncSeq<'T>) : AsyncSeq<'T> = async {
    let! v1 = seq1
    match v1 with
    | Nil -> return! seq2
    | Cons (h,t) -> return Cons(h, append t seq2) }

  /// Computation builder that allows creating of asynchronous
  /// sequences using the 'asyncSeq { ... }' syntax
  type AsyncSeqBuilder() =
    member x.Yield(v) = singleton v
    // This looks weird, but it is needed to allow:
    //
    //     while foo do
    //         do! something
    //
    // because F# translates body as Bind(something, fun () -> Return())
    member x.Return(()) = empty
    member x.YieldFrom(s) = s
    member x.Zero () = empty
    member x.Bind (inp:Async<'T>, body : 'T -> AsyncSeq<'U>) : AsyncSeq<'U> =
      async.Bind(inp, body)

    member x.Combine (seq1:AsyncSeq<'T>, seq2:AsyncSeq<'T>) = append seq1 seq2

    member x.While (gd, seq:AsyncSeq<'T>) =
      if gd() then x.Combine(seq,x.Delay(fun () -> x.While (gd, seq))) else x.Zero()

    member x.Delay (f:unit -> AsyncSeq<'T>) =
      async.Delay(f)


  /// Builds an asynchronou sequence using the computation builder syntax
  let asyncSeq = new AsyncSeqBuilder()

  /// Tries to get the next element of an asynchronous sequence
  /// and returns either the value or an exception
  let internal tryNext (input:AsyncSeq<_>) = async {
    try
      let! v = input
      return Choice1Of2 v
    with e ->
      return Choice2Of2 e }

  /// Implements the 'TryWith' functionality for computation builder
  let rec internal tryWith (input : AsyncSeq<'T>) handler =    asyncSeq {
    let! v = tryNext input
    match v with
    | Choice1Of2 Nil -> ()
    | Choice1Of2 (Cons (h, t)) ->
      yield h
      yield! tryWith t handler
    | Choice2Of2 rest ->
      yield! handler rest }

  /// Implements the 'TryFinally' functionality for computation builder
  let rec internal tryFinally (input : AsyncSeq<'T>) compensation = asyncSeq {
    let! v = tryNext input
    match v with
    | Choice1Of2 Nil ->
      compensation()
    | Choice1Of2 (Cons (h, t)) ->
      yield h
      yield! tryFinally t compensation
    | Choice2Of2 e ->
      compensation()
      yield! raise e }

  /// Creates an asynchronou sequence that iterates over the given input sequence.
  /// For every input element, it calls the the specified function and iterates
  /// over all elements generated by that asynchronous sequence.
  /// This is the 'bind' operation of the computation expression (exposed using
  /// the 'for' keyword in asyncSeq computation).
  let rec collect f (input : AsyncSeq<'T>) : AsyncSeq<'TResult> = asyncSeq {
    let! v = input
    match v with
    | Nil -> ()
    | Cons(h, t) ->
      yield! f h
      yield! collect f t }

  // Add additional methods to the 'asyncSeq' computation builder
  type AsyncSeqBuilder with

    member x.TryFinally (body: AsyncSeq<'T>, compensation) =
      tryFinally body compensation

    member x.TryWith (body: AsyncSeq<_>, handler: (exn -> AsyncSeq<_>)) =
      tryWith body handler

    member x.Using (resource:#IDisposable, binder) =
      tryFinally (binder resource) (fun () ->
        if box resource <> null then resource.Dispose())

    /// For loop that iterates over a synchronous sequence (and generates
    /// all elements generated by the asynchronous body)
    member x.For(seq:seq<'T>, action:'T -> AsyncSeq<'TResult>) =
      let enum = seq.GetEnumerator()
      x.TryFinally(x.While((fun () -> enum.MoveNext()), x.Delay(fun () ->
        action enum.Current)), (fun () ->
          if enum <> null then enum.Dispose() ))

    /// Asynchronous for loop - for all elements from the input sequence,
    /// generate all elements produced by the body (asynchronously). See
    /// also the AsyncSeq.collect function.
    member x.For (seq:AsyncSeq<'T>, action:'T -> AsyncSeq<'TResult>) =
      collect action seq


  // Add asynchronous for loop to the 'async' computation builder
  type Microsoft.FSharp.Control.AsyncBuilder with

    member x.For (seq:AsyncSeq<'T>, action:'T -> Async<unit>) =
      async.Bind(seq, function
        | Nil -> async.Zero()
        | Cons(h, t) -> async.Combine(action h, x.For(t, action)))

    member x.For (seq:AsyncSeq<'a>, action:'a -> unit) : Async<unit> =
      async.Bind(seq,
        function
        | Nil -> async.Zero()
        | Cons(h, t) -> async { action h ; return! x.For(t, action) })

  // --------------------------------------------------------------------------
  // Additional combinators (implemented as async/asyncSeq computations)

  /// Builds a new asynchronous sequence whose elements are generated by
  /// applying the specified function to all elements of the input sequence.
  ///
  /// The specified function is asynchronous (and the input sequence will
  /// be asked for the next element after the processing of an element completes).
  let mapAsync f (input : AsyncSeq<'T>) : AsyncSeq<'TResult> = asyncSeq {
    for itm in input do
      let! v = f itm
      yield v }

  /// Asynchronously iterates over the input sequence and generates 'x' for
  /// every input element for which the specified asynchronous function
  /// returned 'Some(x)'
  ///
  /// The specified function is asynchronous (and the input sequence will
  /// be asked for the next element after the processing of an element completes).
  let chooseAsync f (input : AsyncSeq<'T>) : AsyncSeq<'R> = asyncSeq {
    for itm in input do
      let! v = f itm
      match v with
      | Some v -> yield v
      | _ -> () }

  /// Builds a new asynchronous sequence whose elements are those from the
  /// input sequence for which the specified function returned true.
  ///
  /// The specified function is asynchronous (and the input sequence will
  /// be asked for the next element after the processing of an element completes).
  let filterAsync f (input:AsyncSeq<'T>) = asyncSeq {
    for v in input do
      let! b = f v
      if b then yield v }

  /// Asynchronously returns the last element that was generated by the
  /// given asynchronous sequence (or the specified default value).
  let rec lastOrDefault def (input:AsyncSeq<'T>) = async {
    let! v = input
    match v with
    | Nil -> return def
    | Cons(h, t) -> return! lastOrDefault h t }

  /// Asynchronously returns the first element that was generated by the
  /// given asynchronous sequence (or the specified default value).
  let firstOrDefault def (input:AsyncSeq<'T>) = async {
    let! v = input
    match v with
    | Nil -> return def
    | Cons(h, _) -> return h }

  /// Asynchronously returns true if the asynchronous sequence contains
  /// no elements, false otherwise
  let isEmpty (input:AsyncSeq<'T>) = async {
    let! v = input
    match v with
    | Nil -> return true
    | Cons _ -> return false }

  /// Aggregates the elements of the input asynchronous sequence using the
  /// specified 'aggregation' function. The result is an asynchronous
  /// sequence of intermediate aggregation result.
  ///
  /// The aggregation function is asynchronous (and the input sequence will
  /// be asked for the next element after the processing of an element completes).
  let rec scanAsync f (state:'TState) (input : AsyncSeq<'T>) = asyncSeq {
    let! v = input
    match v with
    | Nil -> ()
    | Cons(h, t) ->
      let! v = f state h
      yield v
      yield! t |> scanAsync f v }

  /// Iterates over the input sequence and calls the specified function for
  /// every value (to perform some side-effect asynchronously).
  ///
  /// The specified function is asynchronous (and the input sequence will
  /// be asked for the next element after the processing of an element completes).
  let rec iterAsync f (input : AsyncSeq<'T>) = async {
    for itm in input do
      do! f itm }

  /// Maps an async function over an async sequence in parallel.
  /// The output is returned in order, which results in the potential for head-of-line blocking.
  let mapAsyncParallel (f:'a -> Async<'b>) (s:AsyncSeq<'a>) : AsyncSeq<'b> = async {
    use mb = Mb.create ()
    do! s |> iterAsync (fun a -> async {
      let! b = Async.StartChild(f a)
      mb |> Mb.put (Some b)
    })
    mb.Put None
    let rec loop () = async {
      let! b = mb |> Mb.take
      match b with
      | None ->
        return Nil
      | Some b ->
        let! b = b
        return Cons (b, loop ()) }
    return! loop () }

  /// Returns an asynchronous sequence that returns pairs containing an element
  /// from the input sequence and its predecessor. Empty sequence is returned for
  /// singleton input sequence.
  let rec pairwise (input:AsyncSeq<'T>) = asyncSeq {
    let! v = input
    match v with
    | Nil -> ()
    | Cons(h, t) ->
      let prev = ref h
      for v in t do
        yield (!prev, v)
        prev := v }

  /// Aggregates the elements of the input asynchronous sequence using the
  /// specified 'aggregation' function. The result is an asynchronous
  /// workflow that returns the final result.
  ///
  /// The aggregation function is asynchronous (and the input sequence will
  /// be asked for the next element after the processing of an element completes).
  let rec foldAsync f (state:'TState) (input : AsyncSeq<'T>) =
    input |> scanAsync f state |> lastOrDefault state

  /// Same as AsyncSeq.foldAsync, but the specified function is synchronous
  /// and returns the result of aggregation immediately.
  let rec fold f (state:'TState) (input : AsyncSeq<'T>) =
    foldAsync (fun st v -> f st v |> async.Return) state input

  /// Like AsyncSeq.foldAsync but with a possibility of early termination.
  let rec foldAsyncT (f:'State -> 'T -> Async<'State option>) (state:'State) (input:AsyncSeq<'T>) : Async<'State> = async {
    let! input = input
    match input with
    | Nil -> return state
    | Cons (a,tl) ->
      let! result = f state a
      match result with
      | Some result ->
        return! foldAsyncT f result tl
      | None ->
        return state }

  /// Returns the first element for which the given function returns true.
  /// Returns None if no such element exists.
  let rec tryFind (f:'T -> bool) (input:AsyncSeq<'T>) : Async<'T option> = async {
    let! s = input
    match s with
    | Nil -> return None
    | Cons (a,tl) ->
      if f a then return Some a
      else return! tryFind f tl }

  /// Applies the specified function to successive elements returning the first returning Some.
  let rec tryPickAsync (f:'T -> Async<'U option>) (input:AsyncSeq<'T>) : Async<'U option> = async {
    let! s = input
    match s with
    | Nil -> return None
    | Cons (a,tl) ->
      let! r = f a
      match r with
      | Some _ -> return r
      | None -> return! tryPickAsync f tl }

  /// Same as AsyncSeq.scanAsync, but the specified function is synchronous
  /// and returns the result of aggregation immediately.
  let rec scan f (state:'TState) (input : AsyncSeq<'T>) =
    scanAsync (fun st v -> f st v |> async.Return) state input

  /// Same as AsyncSeq.mapAsync, but the specified function is synchronous
  /// and returns the result of projection immediately.
  let map f (input : AsyncSeq<'T>) = asyncSeq { for itm in input do yield f itm }

  /// Same as AsyncSeq.iterAsync, but the specified function is synchronous
  /// and performs the side-effect immediately.
  let iter (f:_ -> unit) (input:AsyncSeq<_>) = async.For(input, f) // async { for itm in input do f itm }

  /// Same as AsyncSeq.chooseAsync, but the specified function is synchronous
  /// and processes the input element immediately.
  let choose f (input:AsyncSeq<'T>) = asyncSeq {
    for itm in input do
      match f itm with
      | Some v -> yield v
      | _ -> () }

  /// Same as AsyncSeq.filterAsync, but the specified predicate is synchronous
  /// and processes the input element immediately.
  let filter f (input : AsyncSeq<'T>) =
    filterAsync (f >> async.Return) input

  /// Creates an asynchronous sequence that lazily takes element from an
  /// input synchronous sequence and returns them one-by-one.
  let ofSeq (input:seq<'T>) = asyncSeq { for el in input do yield el }

  /// Buffer items from the async sequence into buffers of a specified size.
  /// The last buffer returned may be less than the specified buffer size.
  let bufferByCount (bufferSize:int) (s:AsyncSeq<'a>) : AsyncSeq<'a[]> =
    if (bufferSize < 1) then invalidArg "bufferSize" "must be positive"
    async {
      let buffer = ResizeArray<'a>()
      let rec loop s = async {
        let! step = s
        match step with
        | Nil ->
          if (buffer.Count > 0) then return Cons(buffer.ToArray(),async.Return Nil)
          else return Nil
        | Cons(a,tl) ->
          buffer.Add(a)
          if buffer.Count = bufferSize then
            let buf = buffer.ToArray()
            buffer.Clear()
            return Cons(buf, loop tl)
          else
            return! loop tl
      }
      return! loop s
    }

  /// Buffers an async sequence by waiting for a the buffer to reach a certain size or for a specific
  /// amount of time to pass.
  let bufferByTimeAndCount (bufferSize:int) (timeoutMs:int) (s:AsyncSeq<'a>) : AsyncSeq<'a[]> =
    if (bufferSize < 1) then invalidArg "bufferSize" "must be positive"
    if (timeoutMs < 1) then invalidArg "timeoutMs" "must be positive"
    async {
      let buffer = ResizeArray<_>()
      let rec loop s rt = async {
        let t0 = DateTime.Now
        let! choice = Async.chooseBothAny s (Async.Sleep (max 0 rt))
        let delta = int (DateTime.Now - t0).TotalMilliseconds
        match choice with
        | Choice1Of2 (Nil,_) ->
          if (buffer.Count > 0) then return Cons(buffer.ToArray(),async.Return Nil)
          else return Nil
        | Choice1Of2 (Cons(a,tl),_) ->
          buffer.Add(a)
          if buffer.Count = bufferSize then
            let buf = buffer.ToArray()
            buffer.Clear()
            return Cons(buf, loop tl timeoutMs)
          else
            return! loop tl (rt - delta)
        | Choice2Of2 ((),tl) ->
          if buffer.Count > 0 then
            let buf = buffer.ToArray()
            buffer.Clear()
            return Cons(buf, loop tl timeoutMs)
          else
            return! loop tl timeoutMs
      }
      return! loop s timeoutMs
    }


  // -------------------------------------------------------------------------------------------------------------------------


  /// Converts asynchronous sequence to an IObservable<_>. When the client subscribes
  /// to the observable, a new copy of asynchronous sequence is started and is
  /// sequentially iterated over (at the maximal possible speed). Disposing of the
  /// observer cancels the iteration over asynchronous sequence.
  let toObservable (s:AsyncSeq<_>) =
    let start (obs:IObserver<_>) = async {
      try
        for v in s do obs.OnNext(v)
        obs.OnCompleted()
      with e ->
        obs.OnError(e) }
    { new IObservable<_> with member __.Subscribe(obs) = start obs |> Async.StartDisposable }


  /// Converts an AsyncSeq into a blocking sequence.
  /// Disposal of the resulting sequence causes iteration to stop.
  /// Exceptions raised during iteration are propagated.
  let toBlockingSeq (s:AsyncSeq<'a>) = seq {

    use buf = new System.Collections.Concurrent.BlockingCollection<_>(1)
    use cts = new CancellationTokenSource()
    use _cancel = { new IDisposable with member __.Dispose() = cts.Cancel() }
    let exn = ref None

    async {
      try
        try do! iter buf.Add s
        finally buf.CompleteAdding()
      with e ->
        exn := Some e
    }
    |> fun p -> Async.Start(p, cancellationToken=cts.Token)

    yield! buf.GetConsumingEnumerable(cts.Token)

    // raise any exception raised during iteration input sequence
    match !exn with
    | Some exn -> raise exn
    | None -> ()

  }

  /// Combines two asynchronous sequences into a sequence of pairs.
  /// The values from sequences are retrieved in parallel.
  let rec zip (input1 : AsyncSeq<'T1>) (input2 : AsyncSeq<'T2>) : AsyncSeq<_> = async {
    let! ft = input1 |> Async.StartChild
    let! s = input2
    let! f = ft
    match f, s with
    | Cons(hf, tf), Cons(hs, ts) ->
      return Cons( (hf, hs), zip tf ts)
    | _ -> return Nil }

  /// Returns elements from an asynchronous sequence while the specified
  /// predicate holds. The predicate is evaluated asynchronously.
  let rec takeWhileAsync p (input : AsyncSeq<'T>) : AsyncSeq<_> = async {
    let! v = input
    match v with
    | Cons(h, t) ->
      let! res = p h
      if res then
        return Cons(h, takeWhileAsync p t)
      else return Nil
    | Nil -> return Nil }

  /// Skips elements from an asynchronous sequence while the specified
  /// predicate holds and then returns the rest of the sequence. The
  /// predicate is evaluated asynchronously.
  let rec skipWhileAsync p (input : AsyncSeq<'T>) : AsyncSeq<_> = async {
    let! v = input
    match v with
    | Cons(h, t) ->
      let! res = p h
      if res then return! skipWhileAsync p t
      else return v//t
    | Nil -> return Nil }

  /// Returns elements from an asynchronous sequence while the specified
  /// predicate holds. The predicate is evaluated synchronously.
  let takeWhile p (input : AsyncSeq<'T>) =
    takeWhileAsync (p >> async.Return) input

  /// Skips elements from an asynchronous sequence while the specified
  /// predicate holds and then returns the rest of the sequence. The
  /// predicate is evaluated asynchronously.
  let rec skipWhile p (input : AsyncSeq<'T>) = async {
    let! v = input
    match v with
    | Cons(h, t) ->
      if (p h) then return! skipWhile p t
      else return v
    | Nil -> return Nil }

  /// Returns the first N elements of an asynchronous sequence
  let rec take count (input:AsyncSeq<'T>) : AsyncSeq<_> = async {
    if count > 0 then
      let! v = input
      match v with
      | Cons(h, t) -> return Cons(h, take (count - 1) t)
      | Nil -> return Nil
    else return Nil }

  /// Skips the first N elements of an asynchronous sequence and
  /// then returns the rest of the sequence unmodified.
  let rec skip count (input : AsyncSeq<'T>) : AsyncSeq<_> = async {
    if count > 0 then
      let! v = input
      match v with
      | Cons(_, t) ->
        return! skip (count - 1) t
      | Nil -> return Nil
    else return! input }

  let interleave =
    let rec left (a:AsyncSeq<'a>) (b:AsyncSeq<'b>) : AsyncSeq<Choice<_,_>> = async {
      let! a = a
      match a with
      | Cons (a1, t1) -> return Cons (Choice1Of2 a1, right t1 b)
      | Nil -> return! b |> map Choice2Of2 }
    and right (a:AsyncSeq<'a>) (b:AsyncSeq<'b>) : AsyncSeq<Choice<_,_>> = async {
      let! b = b
      match b with
      | Cons (a2, t2) -> return Cons (Choice2Of2 a2, left a t2)
      | Nil -> return! a |> map Choice1Of2 }
    left

  /// Iterates the async sequence using the specified function. After the first item is retrieved, retrieval of subseqent items runs in parrallel to the
  /// function.
  let iterAsyncFetchParallel (f:'a -> Async<unit>) (s:AsyncSeq<'a>) : Async<unit> = async {
    let rec go s = async {
      match s with
      | Nil -> return ()
      | Cons (a,tl) ->
        let! s,_ = Async.Parallel (tl, f a)
        return! go s }
    let! s = s
    return! go s }

  /// Iterates the async sequence using the specified function, starting each invocation concurrently on a thread pool thread.
  let iterAsyncParallel (f:'a -> Async<unit>) (s:AsyncSeq<'a>) : Async<unit> = async {
    use cde = new CountdownEvent(1)
    let tcs = new TaskCompletionSource<unit>()
    let inline tryComplete () =
      if cde.Signal() then
        tcs.SetResult(())
    let inline ok (_:unit) =
      tryComplete ()
    let inline err (ex:exn) =
      tcs.TrySetException ex |> ignore
    let inline cnc (_:OperationCanceledException) =
      tcs.TrySetCanceled() |> ignore
    let rec loop s = async {
      let! s = s
      match s with
      | Nil -> return ()
      | Cons (a,tl) ->
        cde.AddCount(1)
        Async.StartThreadPoolWithContinuations (f a, ok, err, cnc)
        return! loop tl }
    do! loop s
    tryComplete ()
    do! tcs.Task |> Async.AwaitTask }

  /// Flattens a projection of AsyncSeq to sequences.
  let rec collectSeq (f:'a -> #seq<'b>) (s:AsyncSeq<'a>) : AsyncSeq<'b> = asyncSeq {
    let! s = s
    match s with
    | Nil -> ()
    | Cons (head,tail) ->
      for item in f head do yield item
      yield! collectSeq f tail }

  /// Flattens an AsyncSeq of sequences.
  let rec concatSeq (s:AsyncSeq<#seq<'a>>) : AsyncSeq<'a> = asyncSeq {
    let! v = s
    match v with
    | Nil -> ()
    | Cons (h, t) ->
      for item in h do
        yield item
      yield! concatSeq t }

  /// Generates an async sequence using the specified generator function.
  let rec unfoldAsync (f:'State -> Async<('a * 'State) option>) (s:'State) : AsyncSeq<'a> = asyncSeq {
    let! r = f s
    match r with
    | Some (a,s) ->
      yield a
      yield! unfoldAsync f s
    | None -> () }

  /// Iterates the AsyncSeq and collects the output into an array.
  let toArray (s:AsyncSeq<'a>) : Async<'a[]> =
    s
    |> fold (fun (arr:ResizeArray<'a>) a -> arr.Add(a) ; arr) (new ResizeArray<'a>())
    |> Async.map (fun arr -> arr.ToArray())

  /// Iterates the AsyncSeq and collects the output into a list.
  let toList (s:AsyncSeq<'a>) : Async<'a list> =
    s
    |> fold (fun arr a -> a::arr) []
    |> Async.map List.rev

  /// Iterates a sequnce of async computations and collects their results into an array.
  let seqOfAsyncToArray (s:seq<Async<'a>>) : Async<'a[]> = async {
    let rs = new ResizeArray<'a>()
    for item in s do
      let! a = item
      rs.Add a
    return rs.ToArray() }

  /// Merges two async sequences into an async sequence non-deterministically.
  let rec merge (a:AsyncSeq<'a>) (b:AsyncSeq<'a>) : AsyncSeq<'a> = async {
    let! one,other = Async.chooseBoth a b
    match one with
    | Nil -> return! other
    | Cons(hd,tl) ->
      return Cons(hd, merge other tl) }

  /// Merges all specified async sequences into an async sequence non-deterministically.
  let rec mergeAll (ss:AsyncSeq<'a> list) : AsyncSeq<'a> =
    match ss with
    | [] -> empty
    | [s] -> s
    | [a;b] -> merge a b
    | hd::tl -> merge hd (mergeAll tl)


  // ---------------------------------------------------------------------------------------------------------------------------------
  // groupBy

  open System.Threading.Tasks
  open System.Collections.Concurrent

  type private EagerSeq<'a> = TaskCompletionSource<EagerCons<'a>>

  and private EagerCons<'a> =
    | EagerCons of 'a * EagerSeq<'a>
    | EagerNil

  let rec private ofEager (e:EagerSeq<'a>) : AsyncSeq<'a> =
    async.Delay <| fun () ->
      e.Task
      |> Async.AwaitTask
      |> Async.map (function
        | EagerNil -> Nil
        | EagerCons(a,tl) -> Cons(a, ofEager tl))

  type private Group<'k, 'a> = { key : 'k ; mutable tail : EagerSeq<'a> }

  /// Partitions an async sequence into groups based on the specified partition function.
  /// The groups remain for the duration of the sequence, therefore care must be take to ensure that too many groups aren't created.
  let groupBy (p:'a -> 'k) (s:AsyncSeq<'a>) : AsyncSeq<AsyncSeq<'a>> = async {
    let groups = Collections.Generic.Dictionary<'k, Group<'k, 'a>>()
    let close g =
      groups.Remove(g.key) |> ignore
      g.tail.SetResult(EagerNil)
    let rec go s = asyncSeq {
      let! s = s
      match s with
      | Nil ->
        groups.Values |> Seq.toArray |> Array.iter close
      | Cons (a,tl) ->
        let k = p a
        let mutable g = Unchecked.defaultof<_>
        if groups.TryGetValue(k, &g) then
          let i = g.tail
          let n = TaskCompletionSource<_>()
          g.tail <- n
          i.SetResult(EagerCons(a, n))
          yield! go tl
        else
          let tl' = TaskCompletionSource<_>()
          let hd = TaskCompletionSource<_>()
          hd.SetResult(EagerCons(a, tl'))
          let g = { key = k ; tail = tl' }
          groups.Add(k, g)
          yield hd |> ofEager
          yield! go tl }
    return! go s }

  // ---------------------------------------------------------------------------------------------------------------------------------

[<AutoOpen>]
module AsyncSeqExtensions =

  /// Builds an asynchronou sequence using the computation builder syntax
  let asyncSeq = new AsyncSeq.AsyncSeqBuilder()

  // Add asynchronous for loop to the 'async' computation builder
  type Microsoft.FSharp.Control.AsyncBuilder with
    member x.For (seq:AsyncSeq<'T>, action:'T -> Async<unit>) =
      async.Bind(seq, function
        | Nil -> async.Zero()
        | Cons(h, t) -> async.Combine(action h, x.For(t, action)))

  // duplicated here from AsyncSeq since I'm not sure why it was commented out
  let toObservable (aseq:AsyncSeq<_>) =
    let start (obs:IObserver<_>) =
      async {
        try
          for v in aseq do obs.OnNext(v)
          obs.OnCompleted()
        with e ->
          obs.OnError(e) }
      |> Async.StartDisposable
    { new IObservable<_> with
      member x.Subscribe(obs) = start obs }